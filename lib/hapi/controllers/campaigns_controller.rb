# hapi
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module Hapi
  # CampaignsController
  class CampaignsController < BaseController
    def initialize(config, http_call_back: nil)
      super(config, http_call_back: http_call_back)
    end

    # Once your Customer has decided on a list of Channels they would like to
    # buy, you can send the list along with
    # publishing information as a `POST` request in order to create a
    # `Campaign`. In return, you'll receive
    # the id of the newly created `Campaign` along with the URL where you can
    # access that Campaign information.
    # For "My Contracts" type of Products, there is no expiration. The vacancy
    # can be taken offline either by the job board or manually, by calling the
    # "[Take a campaign
    # offline](https://vonq.stoplight.io/docs/hapi/b3A6MzM0NDA3MzQ-take-a-campai
    # gn-offline)" endpoint.
    # #### Target group
    # You should use the following endpoints for the target group information:
    # - [**`Industry`**](b3A6MzM0NDA3Mzg-industry-names)
    # - [**`Job Function`**](b3A6MzM0NDA3MzU-job-functions)
    # - [**`Education
    # Level`**](b3A6MzM0NDA3Mzk-retrieve-education-level-taxonomy)
    # - [**`Seniority`**](b3A6MzM0NDA3NDA-retrieve-seniority-taxonomy)
    # @param [CampaignOrderModel] body Required parameter: Example:
    # @param [String] company_id Optional parameter: Example:
    # @param [String] limit Optional parameter: Example:
    # @param [String] offset Optional parameter: Example:
    # @param [String] x_customer_id Optional parameter: The ID of the end-user
    # creating the order. Only required if you are using HAPI Job Post and
    # creating orders with contracts.
    # @return [OrderCampaignSuccessResponseModel] response from the API call
    def order_campaign(body,
                       company_id: nil,
                       limit: nil,
                       offset: nil,
                       x_customer_id: nil)
      begin
        @logger.info("order_campaign called.")
        # Prepare query url.
        @logger.info("Preparing query URL for order_campaign.")
        _query_builder = config.get_base_uri
        _query_builder << '/campaigns/order'
        _query_builder = APIHelper.append_url_with_query_parameters(
          _query_builder,
          'companyId' => company_id,
          'limit' => limit,
          'offset' => offset
        )
        _query_url = APIHelper.clean_url _query_builder
  
        # Prepare headers.
        @logger.info("Preparing headers for order_campaign.")
        _headers = {
          'accept' => 'application/json',
          'Content-Type' => 'application/json',
          'X-Customer-Id' => x_customer_id
        }
  
        # Prepare and execute HttpRequest.
        @logger.info('Preparing and executing HttpRequest for order_campaign.')
        _request = config.http_client.post(
          _query_url,
          headers: _headers,
          parameters: body.to_json
        )
        _response = execute_request(_request, name: 'order_campaign')
  
        # Validate response against endpoint and global error codes.
        @logger.info("Validating response for order_campaign.")
        case _response.status_code
        when 400
          raise OrderCampaignErrorResponseException.new(
            '',
            _response
          )
        end
        validate_response(_response)
  
        # Return appropriate response type.
        @logger.info("Returning response for order_campaign.")
        decoded = APIHelper.json_deserialize(_response.raw_body)
        OrderCampaignSuccessResponseModel.from_hash(decoded)

      rescue Exception => e
        @logger.error(e)
        raise e
      end
    end

    # Displays all the existing Campaigns already ordered for this Partner is as
    # simple as executing a `GET`
    # request against the endpoint `/campaigns`
    # @param [String] company_id Required parameter: CompanyId to filter the
    # results on
    # @param [Float] limit Optional parameter: Amount of products returned
    # @param [Float] offset Optional parameter: Starting point
    # @return [ResultSet1Model] response from the API call
    def list_campaigns(company_id,
                       limit: nil,
                       offset: nil)
      begin
        @logger.info("list_campaigns called.")
        # Prepare query url.
        @logger.info("Preparing query URL for list_campaigns.")
        _query_builder = config.get_base_uri
        _query_builder << '/campaings'
        _query_builder = APIHelper.append_url_with_query_parameters(
          _query_builder,
          'companyId' => company_id,
          'limit' => limit,
          'offset' => offset
        )
        _query_url = APIHelper.clean_url _query_builder
  
        # Prepare headers.
        @logger.info("Preparing headers for list_campaigns.")
        _headers = {
          'accept' => 'application/json'
        }
  
        # Prepare and execute HttpRequest.
        @logger.info('Preparing and executing HttpRequest for list_campaigns.')
        _request = config.http_client.get(
          _query_url,
          headers: _headers
        )
        _response = execute_request(_request, name: 'list_campaigns')
        validate_response(_response)
  
        # Return appropriate response type.
        @logger.info("Returning response for list_campaigns.")
        decoded = APIHelper.json_deserialize(_response.raw_body)
        ResultSet1Model.from_hash(decoded)

      rescue Exception => e
        @logger.error(e)
        raise e
      end
    end

    # Retrieve the details of a specific Campaign. Only Campaigns created by the
    # calling Partner can be
    # retrieved.
    # @param [UUID | String] campaign_id Required parameter: Id of the Campaign
    # that you want to retrieve
    # @return [ListCampaignResponseModel] response from the API call
    def retrieve_campaign(campaign_id)
      begin
        @logger.info("retrieve_campaign called.")
        # Prepare query url.
        @logger.info("Preparing query URL for retrieve_campaign.")
        _query_builder = config.get_base_uri
        _query_builder << '/campaigns/{campaignId}'
        _query_builder = APIHelper.append_url_with_template_parameters(
          _query_builder,
          'campaignId' => { 'value' => campaign_id, 'encode' => true }
        )
        _query_url = APIHelper.clean_url _query_builder
  
        # Prepare headers.
        @logger.info("Preparing headers for retrieve_campaign.")
        _headers = {
          'accept' => 'application/json'
        }
  
        # Prepare and execute HttpRequest.
        @logger.info('Preparing and executing HttpRequest for retrieve_campaign.')
        _request = config.http_client.get(
          _query_url,
          headers: _headers
        )
        _response = execute_request(_request, name: 'retrieve_campaign')
        validate_response(_response)
  
        # Return appropriate response type.
        @logger.info("Returning response for retrieve_campaign.")
        decoded = APIHelper.json_deserialize(_response.raw_body)
        ListCampaignResponseModel.from_hash(decoded)

      rescue Exception => e
        @logger.error(e)
        raise e
      end
    end

    # This is a specialized endpoint for Campaign statuses only. Although the
    # Campaign Details endpoint also returns the
    # status of a campaign, if you only need to get the specific status of a
    # Campaign, this endpoint is
    # optimized for that.
    # @param [UUID | String] campaign_id Required parameter: Id of the Campaign
    # you want the status of
    # @return [CheckCampaignStatusresponseModel] response from the API call
    def check_campaign_status(campaign_id)
      begin
        @logger.info("check_campaign_status called.")
        # Prepare query url.
        @logger.info("Preparing query URL for check_campaign_status.")
        _query_builder = config.get_base_uri
        _query_builder << '/campaigns/{campaignId}/status'
        _query_builder = APIHelper.append_url_with_template_parameters(
          _query_builder,
          'campaignId' => { 'value' => campaign_id, 'encode' => true }
        )
        _query_url = APIHelper.clean_url _query_builder
  
        # Prepare headers.
        @logger.info("Preparing headers for check_campaign_status.")
        _headers = {
          'accept' => 'application/json'
        }
  
        # Prepare and execute HttpRequest.
        @logger.info('Preparing and executing HttpRequest for check_campaign_status.')
        _request = config.http_client.get(
          _query_url,
          headers: _headers
        )
        _response = execute_request(_request, name: 'check_campaign_status')
        validate_response(_response)
  
        # Return appropriate response type.
        @logger.info("Returning response for check_campaign_status.")
        decoded = APIHelper.json_deserialize(_response.raw_body)
        CheckCampaignStatusresponseModel.from_hash(decoded)

      rescue Exception => e
        @logger.error(e)
        raise e
      end
    end

    # Specific endpoint to take a campaign offline. Keep in mind that processing
    # this might
    # take some time and it only has an effect if the campaign's status is
    # "online".
    # @param [UUID | String] campaign_id Required parameter: Id of the Campaign
    # you want to take offline
    # @param [TakeCampaignOfflineRequestModel] body Required parameter:
    # Example:
    # @return [TakeCampaignOfflineResponseModel] response from the API call
    def take_campaign_offline(campaign_id,
                              body)
      begin
        @logger.info("take_campaign_offline called.")
        # Prepare query url.
        @logger.info("Preparing query URL for take_campaign_offline.")
        _query_builder = config.get_base_uri
        _query_builder << '/campaigns/{campaignId}/cancellation'
        _query_builder = APIHelper.append_url_with_template_parameters(
          _query_builder,
          'campaignId' => { 'value' => campaign_id, 'encode' => true }
        )
        _query_url = APIHelper.clean_url _query_builder
  
        # Prepare headers.
        @logger.info("Preparing headers for take_campaign_offline.")
        _headers = {
          'accept' => 'application/json',
          'Content-Type' => 'application/json'
        }
  
        # Prepare and execute HttpRequest.
        @logger.info('Preparing and executing HttpRequest for take_campaign_offline.')
        _request = config.http_client.put(
          _query_url,
          headers: _headers,
          parameters: body.to_json
        )
        _response = execute_request(_request, name: 'take_campaign_offline')
  
        # Validate response against endpoint and global error codes.
        @logger.info("Validating response for take_campaign_offline.")
        case _response.status_code
        when 400
          raise TakeCampaignOfflineErrorResponse2Exception.new(
            '',
            _response
          )
        when 404
          raise TakeCampaignOfflineErrorResponseException.new(
            '',
            _response
          )
        end
        validate_response(_response)
  
        # Return appropriate response type.
        @logger.info("Returning response for take_campaign_offline.")
        decoded = APIHelper.json_deserialize(_response.raw_body)
        TakeCampaignOfflineResponseModel.from_hash(decoded)

      rescue Exception => e
        @logger.error(e)
        raise e
      end
    end
  end
end
